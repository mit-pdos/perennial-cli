// depgraph analyzes Rocq Makefile dependencies
//
// Processes files generated by `rocq dep`.
package depgraph

import (
	"bufio"
	"io"
	"slices"
	"strings"

	orderedmap "github.com/pb33f/ordered-map/v2"
)

// This file implements generic algorithms for Makefile dependencies (not specialized to Rocq)

type Dep struct {
	Target string
	Source string
}

type Graph struct {
	deps  []Dep
	nodes *orderedmap.OrderedMap[string, struct{}]
}

func (g *Graph) Len() int {
	return len(g.deps)
}

// allDeps is for testing
func (g *Graph) allDeps() []Dep {
	return g.deps
}

// Parse dependencies from a .d file
func Parse(r io.Reader) (*Graph, error) {
	scanner := bufio.NewScanner(r)
	var deps []Dep
	nodes := orderedmap.New[string, struct{}]()

	for scanner.Scan() {
		line := scanner.Text()

		// Skip empty lines and comments
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// Parse "target1 target2: dep1 dep2 dep3" format
		parts := strings.SplitN(line, ":", 2)
		if len(parts) != 2 {
			continue
		}

		targets := strings.Fields(parts[0])
		dependencies := strings.Fields(parts[1])

		// Create a Dep for each (dependency, target) pair
		for _, target := range targets {
			nodes.Set(target, struct{}{})
			for _, dep := range dependencies {
				deps = append(deps, Dep{
					Target: target,
					Source: dep,
				})
				nodes.Set(dep, struct{}{})
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return &Graph{deps: deps, nodes: nodes}, nil
}

func (g *Graph) FilterNodes(keep func(string) bool) {
	var filteredDeps []Dep
	for _, dep := range g.deps {
		if keep(dep.Target) && keep(dep.Source) {
			filteredDeps = append(filteredDeps, dep)
		}
	}
	for node := range g.nodes.KeysFromOldest() {
		if !keep(node) {
			g.nodes.Delete(node)
		}
	}
	g.deps = filteredDeps
}

type DepChain struct {
	// starts with target and ends with final source
	path []string
}

func (c DepChain) Targets() []string {
	return c.path[:len(c.path)-1]
}

func (c DepChain) Sources() []string {
	return c.path[1:]
}

func (c DepChain) Source() string {
	return c.path[len(c.path)-1]
}

// Deps gets all transitive dependencies of targets
func (g *Graph) Deps(targets []string) []DepChain {
	// Build adjacency list: target -> list of sources
	adjacency := orderedmap.New[string, []string]()
	for _, dep := range g.deps {
		sources, _ := adjacency.Get(dep.Target)
		adjacency.Set(dep.Target, append(sources, dep.Source))
	}

	var chains []DepChain
	visited := make(map[string]bool)
	addedSources := make(map[string]bool)

	// BFS with path tracking
	type queueItem struct {
		node string
		path []string
	}
	var queue []queueItem
	for _, target := range targets {
		queue = append(queue, queueItem{node: target, path: []string{target}})
		visited[target] = true
	}

	for len(queue) > 0 {
		item := queue[0]
		queue = queue[1:]

		sources, hasDeps := adjacency.Get(item.node)
		if !hasDeps {
			// Leaf node - this is a complete dependency chain
			if len(item.path) > 1 {
				// Only add chains that have at least one dependency
				source := item.path[len(item.path)-1]
				if !addedSources[source] {
					addedSources[source] = true
					chains = append(chains, DepChain{path: slices.Clone(item.path)})
				}
			}
			continue
		}

		// Visit all dependencies
		for _, source := range sources {
			newPath := append(slices.Clone(item.path), source)

			if !visited[source] {
				visited[source] = true
				queue = append(queue, queueItem{node: source, path: newPath})
			}
		}
	}

	return chains
}

// Targets returns all nodes that transitively depend on any of the sources.
func (g *Graph) Targets(sources []string) []string {
	// This is not simply Deps() on the reverse-dependency graph: that returns
	// de-duplicated DepChains
	// (potentially missing intermediate nodes in diamond patterns), while this BFS
	// returns ALL reachable nodes in the reverse dependency graph.

	// Build adjacency list for reverse dependencies
	adjacency := orderedmap.New[string, []string]()
	for _, dep := range g.deps {
		// dep.Target depends on dep.Source
		// So dep.Source is depended on by dep.Target
		targets, _ := adjacency.Get(dep.Source)
		adjacency.Set(dep.Source, append(targets, dep.Target))
	}

	// BFS to find all reachable nodes
	seen := orderedmap.New[string, struct{}]()
	visited := make(map[string]bool)
	queue := slices.Clone(sources)
	for _, src := range sources {
		visited[src] = true
	}

	for len(queue) > 0 {
		node := queue[0]
		queue = queue[1:]

		dependents, hasDeps := adjacency.Get(node)
		if !hasDeps {
			continue
		}

		for _, dependent := range dependents {
			if !visited[dependent] {
				visited[dependent] = true
				queue = append(queue, dependent)
				seen.Set(dependent, struct{}{})
			}
		}
	}

	return slices.Collect(seen.KeysFromOldest())
}
